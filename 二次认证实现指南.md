# GIN-vue-admin 二次认证实现指南

## 概述

本指南将详细说明如何在GIN-vue-admin项目中集成Google Authenticator二次认证（2FA）功能。该功能基于TOTP（Time-based One-Time Password）算法，为用户提供额外的安全保护。

## 当前项目状态

- ✅ 用户模型已包含`GoogleSecret`字段
- ✅ 项目依赖已包含`github.com/pquerna/otp`库
- ✅ 基础JWT认证系统已实现
- ❌ 缺少二次认证相关API接口
- ❌ 缺少前端二次认证界面
- ❌ 缺少二次认证中间件

## 实现方案

### 1. 后端实现

#### 1.1 创建TOTP工具类

**文件位置**: `server/utils/totp.go`

```go
package utils

import (
	"crypto/rand"
	"encoding/base32"
	"fmt"
	"time"

	"github.com/pquerna/otp"
	"github.com/pquerna/otp/totp"
)

// GenerateSecret 生成TOTP密钥
func GenerateSecret(username string) (string, string, error) {
	key, err := totp.Generate(totp.GenerateOpts{
		Issuer:      "GIN-vue-admin",
		AccountName: username,
		SecretSize:  32,
	})
	if err != nil {
		return "", "", err
	}
	return key.Secret(), key.URL(), nil
}

// ValidateTOTP 验证TOTP码
func ValidateTOTP(secret, code string) bool {
	return totp.Validate(code, secret)
}

// GenerateQRCode 生成二维码内容
func GenerateQRCode(secret, username string) string {
	return fmt.Sprintf("otpauth://totp/GIN-vue-admin:%s?secret=%s&issuer=GIN-vue-admin", username, secret)
}
```

#### 1.2 扩展用户请求模型

**文件位置**: `server/model/system/request/sys_user.go`

在现有结构体中添加：

```go
// Enable2FA 启用二次认证请求
type Enable2FA struct {
	Code string `json:"code" binding:"required" example:"123456"` // 验证码
}

// Verify2FA 验证二次认证请求
type Verify2FA struct {
	Code string `json:"code" binding:"required" example:"123456"` // 验证码
}

// LoginWith2FA 带二次认证的登录请求
type LoginWith2FA struct {
	Username  string `json:"username" binding:"required"`  // 用户名
	Password  string `json:"password" binding:"required"`  // 密码
	Code      string `json:"code" binding:"required"`      // 二次认证码
	Captcha   string `json:"captcha"`                      // 验证码
	CaptchaId string `json:"captchaId"`                    // 验证码ID
}
```

#### 1.3 创建二次认证服务

**文件位置**: `server/service/system/sys_user_2fa.go`

```go
package system

import (
	"errors"
	"github.com/kuihuar/huasu-admin/server/global"
	"github.com/kuihuar/huasu-admin/server/model/system"
	"github.com/kuihuar/huasu-admin/server/utils"
	"gorm.io/gorm"
)

type User2FAService struct{}

var User2FAServiceApp = new(User2FAService)

// Enable2FA 启用二次认证
func (s *User2FAService) Enable2FA(userID uint, code string) error {
	var user system.SysUser
	if err := global.GVA_DB.First(&user, userID).Error; err != nil {
		return err
	}
	
	if user.GoogleSecret == "" {
		return errors.New("请先生成密钥")
	}
	
	if !utils.ValidateTOTP(user.GoogleSecret, code) {
		return errors.New("验证码错误")
	}
	
	// 更新用户状态，标记已启用2FA
	user.Enable2FA = true
	return global.GVA_DB.Save(&user).Error
}

// Disable2FA 禁用二次认证
func (s *User2FAService) Disable2FA(userID uint, code string) error {
	var user system.SysUser
	if err := global.GVA_DB.First(&user, userID).Error; err != nil {
		return err
	}
	
	if !utils.ValidateTOTP(user.GoogleSecret, code) {
		return errors.New("验证码错误")
	}
	
	user.Enable2FA = false
	user.GoogleSecret = ""
	return global.GVA_DB.Save(&user).Error
}

// Generate2FASecret 生成二次认证密钥
func (s *User2FAService) Generate2FASecret(userID uint) (string, string, error) {
	var user system.SysUser
	if err := global.GVA_DB.First(&user, userID).Error; err != nil {
		return "", "", err
	}
	
	secret, qrCode, err := utils.GenerateSecret(user.Username)
	if err != nil {
		return "", "", err
	}
	
	// 保存密钥到数据库
	user.GoogleSecret = secret
	if err := global.GVA_DB.Save(&user).Error; err != nil {
		return "", "", err
	}
	
	return secret, qrCode, nil
}

// Verify2FACode 验证二次认证码
func (s *User2FAService) Verify2FACode(userID uint, code string) error {
	var user system.SysUser
	if err := global.GVA_DB.First(&user, userID).Error; err != nil {
		return err
	}
	
	if user.GoogleSecret == "" {
		return errors.New("未启用二次认证")
	}
	
	if !utils.ValidateTOTP(user.GoogleSecret, code) {
		return errors.New("验证码错误")
	}
	
	return nil
}
```

#### 1.4 创建二次认证API

**文件位置**: `server/api/v1/system/sys_user_2fa.go`

```go
package system

import (
	"github.com/gin-gonic/gin"
	"github.com/kuihuar/huasu-admin/server/global"
	"github.com/kuihuar/huasu-admin/server/model/common/response"
	systemReq "github.com/kuihuar/huasu-admin/server/model/system/request"
	"github.com/kuihuar/huasu-admin/server/service"
	"github.com/kuihuar/huasu-admin/server/utils"
	"go.uber.org/zap"
)

type User2FAApi struct{}

// Generate2FASecret 生成二次认证密钥
// @Tags     SysUser
// @Summary  生成二次认证密钥
// @Security  ApiKeyAuth
// @accept    application/json
// @Produce   application/json
// @Success   200  {object}  response.Response{data=map[string]interface{}}  "生成成功"
// @Router    /user/generate2fa [post]
func (u *User2FAApi) Generate2FASecret(c *gin.Context) {
	claims := utils.GetUserInfo(c)
	userID := claims.ID
	
	secret, qrCode, err := service.User2FAServiceApp.Generate2FASecret(userID)
	if err != nil {
		global.GVA_LOG.Error("生成二次认证密钥失败!", zap.Error(err))
		response.FailWithMessage("生成密钥失败", c)
		return
	}
	
	response.OkWithDetailed(gin.H{
		"secret":  secret,
		"qrCode":  qrCode,
	}, "生成成功", c)
}

// Enable2FA 启用二次认证
// @Tags     SysUser
// @Summary  启用二次认证
// @Security  ApiKeyAuth
// @accept    application/json
// @Produce   application/json
// @Param    data  body      systemReq.Enable2FA  true  "启用二次认证"
// @Success   200  {object}  response.Response     "启用成功"
// @Router    /user/enable2fa [post]
func (u *User2FAApi) Enable2FA(c *gin.Context) {
	var req systemReq.Enable2FA
	if err := c.ShouldBindJSON(&req); err != nil {
		response.FailWithMessage(err.Error(), c)
		return
	}
	
	claims := utils.GetUserInfo(c)
	userID := claims.ID
	
	if err := service.User2FAServiceApp.Enable2FA(userID, req.Code); err != nil {
		global.GVA_LOG.Error("启用二次认证失败!", zap.Error(err))
		response.FailWithMessage(err.Error(), c)
		return
	}
	
	response.OkWithMessage("启用成功", c)
}

// Disable2FA 禁用二次认证
// @Tags     SysUser
// @Summary  禁用二次认证
// @Security  ApiKeyAuth
// @accept    application/json
// @Produce   application/json
// @Param    data  body      systemReq.Verify2FA  true  "禁用二次认证"
// @Success   200  {object}  response.Response     "禁用成功"
// @Router    /user/disable2fa [post]
func (u *User2FAApi) Disable2FA(c *gin.Context) {
	var req systemReq.Verify2FA
	if err := c.ShouldBindJSON(&req); err != nil {
		response.FailWithMessage(err.Error(), c)
		return
	}
	
	claims := utils.GetUserInfo(c)
	userID := claims.ID
	
	if err := service.User2FAServiceApp.Disable2FA(userID, req.Code); err != nil {
		global.GVA_LOG.Error("禁用二次认证失败!", zap.Error(err))
		response.FailWithMessage(err.Error(), c)
		return
	}
	
	response.OkWithMessage("禁用成功", c)
}

// Verify2FA 验证二次认证码
// @Tags     SysUser
// @Summary  验证二次认证码
// @Security  ApiKeyAuth
// @accept    application/json
// @Produce   application/json
// @Param    data  body      systemReq.Verify2FA  true  "验证二次认证码"
// @Success   200  {object}  response.Response     "验证成功"
// @Router    /user/verify2fa [post]
func (u *User2FAApi) Verify2FA(c *gin.Context) {
	var req systemReq.Verify2FA
	if err := c.ShouldBindJSON(&req); err != nil {
		response.FailWithMessage(err.Error(), c)
		return
	}
	
	claims := utils.GetUserInfo(c)
	userID := claims.ID
	
	if err := service.User2FAServiceApp.Verify2FACode(userID, req.Code); err != nil {
		global.GVA_LOG.Error("验证二次认证码失败!", zap.Error(err))
		response.FailWithMessage(err.Error(), c)
		return
	}
	
	response.OkWithMessage("验证成功", c)
}
```

#### 1.5 修改登录API支持二次认证

**文件位置**: `server/api/v1/system/sys_user.go`

在现有的Login函数中添加二次认证逻辑：

```go
// 在Login函数中，在b.TokenNext(c, *user)之前添加：
if user.GoogleSecret != "" {
	// 用户已启用二次认证，需要验证TOTP码
	if l.Code == "" {
		response.FailWithMessage("请输入二次认证码", c)
		return
	}
	
	if !utils.ValidateTOTP(user.GoogleSecret, l.Code) {
		global.GVA_LOG.Error("二次认证码错误!")
		response.FailWithMessage("二次认证码错误", c)
		return
	}
}
```

#### 1.6 添加路由

**文件位置**: `server/router/system/sys_user_2fa.go`

```go
package system

import (
	"github.com/gin-gonic/gin"
	"github.com/kuihuar/huasu-admin/server/api/v1"
	"github.com/kuihuar/huasu-admin/server/middleware"
)

type User2FARouter struct{}

func (s *User2FARouter) InitUser2FARouter(Router *gin.RouterGroup) {
	user2FARouter := Router.Group("user").Use(middleware.OperationRecord())
	{
		user2FARouter.POST("generate2fa", v1.User2FAApiApp.Generate2FASecret)
		user2FARouter.POST("enable2fa", v1.User2FAApiApp.Enable2FA)
		user2FARouter.POST("disable2fa", v1.User2FAApiApp.Disable2FA)
		user2FARouter.POST("verify2fa", v1.User2FAApiApp.Verify2FA)
	}
}
```

**文件位置**: `server/api/v1/system/enter.go`

```go
// 添加
var (
	// ... 其他变量
	User2FAApiApp = new(User2FAApi)
)
```

**文件位置**: `server/router/system/enter.go`

```go
// 添加
var (
	// ... 其他变量
	User2FARouter = &User2FARouter{}
)
```

### 2. 前端实现

#### 2.1 创建二次认证API接口

**文件位置**: `web/src/api/user2fa.js`

```javascript
import service from '@/utils/request'

export const generate2FASecret = () => {
  return service({
    url: '/user/generate2fa',
    method: 'post'
  })
}

export const enable2FA = (data) => {
  return service({
    url: '/user/enable2fa',
    method: 'post',
    data
  })
}

export const disable2FA = (data) => {
  return service({
    url: '/user/disable2fa',
    method: 'post',
    data
  })
}

export const verify2FA = (data) => {
  return service({
    url: '/user/verify2fa',
    method: 'post',
    data
  })
}
```

#### 2.2 创建二次认证组件

**文件位置**: `web/src/components/User2FA/index.vue`

```vue
<template>
  <div class="user-2fa">
    <el-card>
      <template #header>
        <div class="card-header">
          <span>二次认证设置</span>
        </div>
      </template>
      
      <div v-if="!is2FAEnabled">
        <el-alert
          title="二次认证未启用"
          type="warning"
          :closable="false"
          show-icon
        />
        
        <div class="setup-section">
          <el-button type="primary" @click="generateSecret" :loading="generating">
            启用二次认证
          </el-button>
        </div>
        
        <div v-if="qrCodeUrl" class="qr-section">
          <h4>请使用Google Authenticator扫描二维码：</h4>
          <div class="qr-code">
            <img :src="qrCodeUrl" alt="QR Code" />
          </div>
          <p>或者手动输入密钥：{{ secret }}</p>
          
          <el-form :model="enableForm" :rules="enableRules" ref="enableFormRef">
            <el-form-item label="验证码" prop="code">
              <el-input
                v-model="enableForm.code"
                placeholder="请输入6位验证码"
                maxlength="6"
              />
            </el-form-item>
            <el-form-item>
              <el-button type="primary" @click="enable2FA" :loading="enabling">
                确认启用
              </el-button>
              <el-button @click="cancelSetup">取消</el-button>
            </el-form-item>
          </el-form>
        </div>
      </div>
      
      <div v-else>
        <el-alert
          title="二次认证已启用"
          type="success"
          :closable="false"
          show-icon
        />
        
        <div class="disable-section">
          <el-form :model="disableForm" :rules="disableRules" ref="disableFormRef">
            <el-form-item label="验证码" prop="code">
              <el-input
                v-model="disableForm.code"
                placeholder="请输入6位验证码"
                maxlength="6"
              />
            </el-form-item>
            <el-form-item>
              <el-button type="danger" @click="disable2FA" :loading="disabling">
                禁用二次认证
              </el-button>
            </el-form-item>
          </el-form>
        </div>
      </div>
    </el-card>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'
import { generate2FASecret, enable2FA, disable2FA } from '@/api/user2fa'
import QRCode from 'qrcode'

const is2FAEnabled = ref(false)
const generating = ref(false)
const enabling = ref(false)
const disabling = ref(false)
const qrCodeUrl = ref('')
const secret = ref('')

const enableForm = reactive({
  code: ''
})

const disableForm = reactive({
  code: ''
})

const enableFormRef = ref()
const disableFormRef = ref()

const enableRules = {
  code: [
    { required: true, message: '请输入验证码', trigger: 'blur' },
    { pattern: /^\d{6}$/, message: '验证码必须是6位数字', trigger: 'blur' }
  ]
}

const disableRules = {
  code: [
    { required: true, message: '请输入验证码', trigger: 'blur' },
    { pattern: /^\d{6}$/, message: '验证码必须是6位数字', trigger: 'blur' }
  ]
}

const generateSecret = async () => {
  try {
    generating.value = true
    const res = await generate2FASecret()
    if (res.code === 0) {
      secret.value = res.data.secret
      // 生成二维码
      qrCodeUrl.value = await QRCode.toDataURL(res.data.qrCode)
    }
  } catch (error) {
    ElMessage.error('生成密钥失败')
  } finally {
    generating.value = false
  }
}

const enable2FAHandler = async () => {
  try {
    await enableFormRef.value.validate()
    enabling.value = true
    const res = await enable2FA(enableForm)
    if (res.code === 0) {
      ElMessage.success('二次认证启用成功')
      is2FAEnabled.value = true
      cancelSetup()
    }
  } catch (error) {
    ElMessage.error('启用失败')
  } finally {
    enabling.value = false
  }
}

const disable2FAHandler = async () => {
  try {
    await ElMessageBox.confirm('确定要禁用二次认证吗？', '提示', {
      confirmButtonText: '确定',
      cancelButtonText: '取消',
      type: 'warning'
    })
    
    await disableFormRef.value.validate()
    disabling.value = true
    const res = await disable2FA(disableForm)
    if (res.code === 0) {
      ElMessage.success('二次认证已禁用')
      is2FAEnabled.value = false
      disableForm.code = ''
    }
  } catch (error) {
    if (error !== 'cancel') {
      ElMessage.error('禁用失败')
    }
  } finally {
    disabling.value = false
  }
}

const cancelSetup = () => {
  qrCodeUrl.value = ''
  secret.value = ''
  enableForm.code = ''
}

onMounted(() => {
  // 检查用户是否已启用二次认证
  // 这里需要根据实际API调整
})
</script>

<style scoped>
.user-2fa {
  max-width: 600px;
  margin: 0 auto;
}

.setup-section {
  margin: 20px 0;
  text-align: center;
}

.qr-section {
  margin-top: 20px;
  text-align: center;
}

.qr-code {
  margin: 20px 0;
}

.qr-code img {
  max-width: 200px;
  height: auto;
}

.disable-section {
  margin-top: 20px;
}
</style>
```

#### 2.3 修改登录页面

**文件位置**: `web/src/view/login/index.vue`

在登录表单中添加二次认证码输入框：

```vue
<!-- 在密码输入框后添加 -->
<el-form-item
  v-if="show2FA"
  prop="code"
  :rules="[{ required: true, message: '请输入二次认证码', trigger: 'blur' }]"
>
  <el-input
    v-model="loginForm.code"
    placeholder="请输入6位二次认证码"
    maxlength="6"
    show-password
  >
    <template #prefix>
      <el-icon class="el-input__icon">
        <Lock />
      </el-icon>
    </template>
  </el-input>
</el-form-item>
```

在登录逻辑中添加二次认证处理：

```javascript
// 在登录方法中添加
const handleLogin = async () => {
  try {
    const res = await login(loginForm)
    if (res.code === 0) {
      // 检查是否需要二次认证
      if (res.data.need2FA) {
        show2FA.value = true
        ElMessage.info('请输入二次认证码')
        return
      }
      // 正常登录流程
      await userStore.LoginIn(loginForm)
    }
  } catch (error) {
    // 错误处理
  }
}
```

### 3. 数据库迁移

#### 3.1 添加Enable2FA字段

需要在用户表中添加`enable_2fa`字段：

```sql
ALTER TABLE sys_users ADD COLUMN enable_2fa BOOLEAN DEFAULT FALSE COMMENT '是否启用二次认证';
```

#### 3.2 更新用户模型

**文件位置**: `server/model/system/sys_user.go`

```go
type SysUser struct {
    // ... 现有字段
    GoogleSecret  string `json:"googleSecret" gorm:"column:google_secret;comment:Google验证密钥"`
    Enable2FA     bool   `json:"enable2fa" gorm:"column:enable_2fa;default:false;comment:是否启用二次认证"`
}
```

### 4. 配置更新

#### 4.1 添加二次认证配置

**文件位置**: `server/config/config.go`

```go
type System struct {
    // ... 现有配置
    Enable2FA bool `mapstructure:"enable-2fa" json:"enable-2fa" yaml:"enable-2fa"` // 是否启用二次认证
}
```

#### 4.2 更新配置文件

**文件位置**: `server/config.yaml`

```yaml
system:
  # ... 现有配置
  enable-2fa: true  # 启用二次认证
```

### 5. 测试

#### 5.1 后端测试

```bash
# 启动服务
cd server
go run main.go

# 测试API
curl -X POST http://localhost:8888/api/generate2fa \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"

curl -X POST http://localhost:8888/api/enable2fa \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"code":"123456"}'
```

#### 5.2 前端测试

1. 访问用户设置页面
2. 点击"启用二次认证"
3. 使用Google Authenticator扫描二维码
4. 输入验证码完成设置
5. 重新登录测试二次认证

### 6. 安全注意事项

1. **密钥安全**: GoogleSecret字段应该加密存储
2. **验证码有效期**: TOTP码有30秒有效期，需要处理时间窗口
3. **错误处理**: 限制验证失败次数，防止暴力破解
4. **备份码**: 建议提供备用恢复码
5. **日志记录**: 记录二次认证相关操作日志

### 7. 部署说明

1. 确保数据库已更新（添加新字段）
2. 更新配置文件
3. 重新编译并部署后端服务
4. 更新前端代码并部署
5. 测试功能是否正常工作

## 总结

通过以上步骤，您可以在GIN-vue-admin项目中成功集成Google Authenticator二次认证功能。这将大大提升系统的安全性，为用户提供额外的保护层。

如果在实施过程中遇到问题，请检查：
1. 数据库字段是否正确添加
2. API路由是否正确配置
3. 前端组件是否正确引入
4. 依赖库是否正确安装
